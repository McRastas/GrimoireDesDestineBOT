# commands/verifier_maj.py
import discord
from discord import app_commands
import re
from .base import BaseCommand


class VerifierMajCommand(BaseCommand):

    @property
    def name(self) -> str:
        return "verifier-maj"

    @property
    def description(self) -> str:
        return "V√©rifie et propose des ajustements pour un template de mise √† jour de fiche D&D"

    def register(self, tree: app_commands.CommandTree):
        """Enregistrement avec param√®tre d'ID de message"""

        @tree.command(name=self.name, description=self.description)
        @app_commands.describe(
            message_id="ID du message √† v√©rifier",
            canal="Canal o√π se trouve le message (optionnel, par d√©faut le canal actuel)",
            proposer_corrections="Proposer des corrections automatiques"
        )
        @app_commands.choices(proposer_corrections=[
            app_commands.Choice(name="Oui, proposer des ajustements", value="oui"),
            app_commands.Choice(name="Non, v√©rification seulement", value="non")
        ])
        async def verifier_maj_command(
            interaction: discord.Interaction,
            message_id: str,
            canal: discord.TextChannel = None,
            proposer_corrections: str = "oui"
        ):
            await self.callback(interaction, message_id, canal, proposer_corrections == "oui")

    async def callback(
        self, 
        interaction: discord.Interaction, 
        message_id: str, 
        canal: discord.TextChannel = None,
        proposer_corrections: bool = True
    ):
        try:
            # Utiliser le canal sp√©cifi√© ou le canal actuel
            target_channel = canal or interaction.channel
            
            # R√©cup√©rer le message
            try:
                message_id_int = int(message_id)
                message = await target_channel.fetch_message(message_id_int)
            except ValueError:
                await interaction.response.send_message(
                    "‚ùå L'ID du message doit √™tre un nombre valide.", 
                    ephemeral=True
                )
                return
            except discord.NotFound:
                await interaction.response.send_message(
                    f"‚ùå Message avec l'ID `{message_id}` introuvable dans {target_channel.mention}.", 
                    ephemeral=True
                )
                return
            except discord.Forbidden:
                await interaction.response.send_message(
                    f"‚ùå Pas d'autorisation pour lire les messages dans {target_channel.mention}.", 
                    ephemeral=True
                )
                return

            # Analyser le contenu du message
            content = message.content
            if not content.strip():
                await interaction.response.send_message(
                    "‚ùå Le message est vide ou ne contient que des embeds.", 
                    ephemeral=True
                )
                return

            # Effectuer la v√©rification
            verification_result = self._verify_template(content)
            
            # G√©n√©rer des suggestions si demand√©
            suggestions = None
            if proposer_corrections and verification_result['score'] < verification_result['total_checks']:
                suggestions = self._generate_suggestions(content, verification_result)
            
            # Cr√©er l'embed de r√©sultat
            embed = self._create_verification_embed(message, verification_result, suggestions)
            
            await interaction.response.send_message(embed=embed, ephemeral=True)
            
            # Envoyer le template corrig√© si des corrections sont disponibles
            if suggestions and suggestions.get('corrected_template'):
                await self._send_corrected_template(interaction, suggestions['corrected_template'])

        except Exception as e:
            await interaction.response.send_message(
                f"‚ùå Erreur lors de la v√©rification : {str(e)}", 
                ephemeral=True
            )

    def _verify_template(self, content: str) -> dict:
        """V√©rifie si le contenu respecte le template de mise √† jour de fiche"""
        
        result = {
            'score': 0,
            'total_checks': 0,
            'sections_found': [],
            'sections_missing': [],
            'warnings': [],
            'suggestions': [],
            'details': {},
            'placeholders': []
        }
        
        # √âl√©ments obligatoires √† v√©rifier
        required_patterns = {
            'nom_pj': r'Nom du PJ\s*:\s*(.+)',
            'classe': r'Classe\s*:\s*(.+)',
            'separator_pj_start': r'\*\*\s*/\s*=+\s*PJ\s*=+\s*\\\s*\*\*',
            'quete': r'\*\*Qu√™te\s*:\*\*\s*(.+)',
            'solde_xp': r'\*\*Solde XP\s*:\*\*\s*(.+)',
            'gain_niveau': r'\*\*Gain de niveau\s*:\*\*',
            'pv_calcul': r'PV\s*:\s*(.+)',
            'capacites': r'\*\*¬§\s*Capacit√©s et sorts suppl√©mentaires\s*:\*\*',
            'separator_pj_end': r'\*\*\s*\\\s*=+\s*PJ\s*=+\s*/\s*\*\*',
            'solde_final': r'\*\*¬§\s*Solde\s*:\*\*',
            'fiche_maj': r'\*Fiche R20 √† jour\.\*'
        }
        
        # V√©rifier les √©l√©ments obligatoires
        result['total_checks'] = len(required_patterns)
        
        for key, pattern in required_patterns.items():
            if re.search(pattern, content, re.IGNORECASE | re.MULTILINE):
                result['score'] += 1
                result['sections_found'].append(key)
                
                # Extraire les d√©tails pour certains √©l√©ments
                match = re.search(pattern, content, re.IGNORECASE | re.MULTILINE)
                if match and match.groups():
                    result['details'][key] = match.group(1).strip()
            else:
                result['sections_missing'].append(key)
        
        # Analyser la structure et donner des conseils
        self._analyze_structure(content, result)
        
        return result

    def _analyze_structure(self, content: str, result: dict):
        """Analyse la structure et ajoute des suggestions"""
        
        lines = content.split('\n')
        
        # V√©rifier les calculs XP
        xp_line = None
        for line in lines:
            if re.search(r'\*\*Solde XP\s*:\*\*', line, re.IGNORECASE):
                xp_line = line
                break
        
        if xp_line:
            # Chercher un pattern de calcul : X/Y + Z = W/Y
            if not re.search(r'\d+/\d+\s*\+\s*\d+\s*=\s*\d+/\d+', xp_line):
                if '[' in xp_line:
                    result['warnings'].append("XP non calcul√©s - Des placeholders restent √† remplir")
                else:
                    result['warnings'].append("Format de calcul XP non standard")
        
        # V√©rifier les placeholders non remplis
        placeholders = re.findall(r'\[([A-Z_]+)\]', content)
        result['placeholders'] = list(set(placeholders))  # Supprimer les doublons
        
        if len(result['placeholders']) > 0:
            result['warnings'].append(f"{len(result['placeholders'])} placeholder(s) non rempli(s) : {', '.join(result['placeholders'][:5])}")
        
        # V√©rifier la longueur
        char_count = len(content)
        if char_count > 2000:
            result['warnings'].append(f"Message long ({char_count} caract√®res) - Peut n√©cessiter plusieurs messages")
        elif char_count < 300:
            result['warnings'].append("Message tr√®s court - V√©rifiez si toutes les sections sont pr√©sentes")

    def _generate_suggestions(self, original_content: str, verification_result: dict) -> dict:
        """G√©n√®re des suggestions d'am√©lioration et un template corrig√©"""
        
        suggestions = {
            'corrections': [],
            'ameliorations': [],
            'corrected_template': None,
            'automatic_fixes': []
        }
        
        corrected_content = original_content
        
        # 1. CORRECTIONS AUTOMATIQUES DES S√âPARATEURS
        if 'separator_pj_start' in verification_result['sections_missing']:
            suggestions['automatic_fixes'].append("Ajout du s√©parateur de d√©but PJ")
            # Trouver o√π ins√©rer le s√©parateur (apr√®s Classe)
            if 'Classe' in corrected_content:
                corrected_content = re.sub(
                    r'(Classe\s*:\s*.+)',
                    r'\1\n\n** / =======================  PJ  ========================= \\ **',
                    corrected_content,
                    count=1
                )
        
        if 'separator_pj_end' in verification_result['sections_missing']:
            suggestions['automatic_fixes'].append("Ajout du s√©parateur de fin PJ")
            # Ins√©rer avant le solde final
            if '*Solde' in corrected_content:
                corrected_content = re.sub(
                    r'(\*\*¬§\s*Solde\s*:\*\*)',
                    r'** \\ =======================  PJ  ========================= / **\n\n\1',
                    corrected_content,
                    count=1
                )
        
        # 2. CORRECTIONS DES SECTIONS MANQUANTES
        missing_sections = verification_result['sections_missing']
        
        if 'quete' in missing_sections:
            suggestions['corrections'].append({
                'section': 'Qu√™te',
                'correction': '**Qu√™te :** [TITRE_QUETE] + [NOM_MJ] ‚Å†- [LIEN_MESSAGE_RECOMPENSES]',
                'position': 'Apr√®s les s√©parateurs PJ'
            })
        
        if 'solde_xp' in missing_sections:
            suggestions['corrections'].append({
                'section': 'Solde XP',
                'correction': '**Solde XP :** [XP_ACTUELS]/[XP_REQUIS] + [XP_OBTENUS] = [NOUVEAUX_XP]/[XP_REQUIS] -> üÜô passage au niveau [NOUVEAU_NIVEAU]',
                'position': 'Apr√®s la section Qu√™te'
            })
        
        if 'gain_niveau' in missing_sections:
            suggestions['corrections'].append({
                'section': 'Gain de niveau',
                'correction': '**Gain de niveau :**\nPV : [ANCIENS_PV] + [PV_OBTENUS] = [NOUVEAUX_PV]',
                'position': 'Apr√®s Solde XP'
            })
        
        if 'capacites' in missing_sections:
            suggestions['corrections'].append({
                'section': 'Capacit√©s et sorts',
                'correction': '**¬§ Capacit√©s et sorts suppl√©mentaires :**\nNouvelle(s) capacit√©(s) :\n- [CAPACITE_1]\n- [CAPACITE_2]\nNouveau(x) sort(s) :\n- [SORT_1]\n- [SORT_2]',
                'position': 'Apr√®s Gain de niveau'
            })
        
        # 3. AM√âLIORATIONS SUGG√âR√âES
        if verification_result['placeholders']:
            suggestions['ameliorations'].append({
                'type': 'Placeholders √† remplir',
                'description': f"Remplacer les placeholders : {', '.join(verification_result['placeholders'][:10])}",
                'priority': 'Haute'
            })
        
        # Suggestions bas√©es sur le contenu d√©tect√©
        if 'nom_pj' in verification_result['details']:
            nom_pj = verification_result['details']['nom_pj']
            if '[' in nom_pj:
                suggestions['ameliorations'].append({
                    'type': 'Nom du PJ',
                    'description': f"Remplacer '{nom_pj}' par le vrai nom du personnage",
                    'priority': 'Haute'
                })
        
        if 'classe' in verification_result['details']:
            classe = verification_result['details']['classe']
            if '[' in classe:
                suggestions['ameliorations'].append({
                    'type': 'Classe',
                    'description': f"Remplacer '{classe}' par la vraie classe du personnage",
                    'priority': 'Haute'
                })
        
        # 4. SUGGESTIONS POUR LES CALCULS
        if 'solde_xp' in verification_result['details']:
            xp_line = verification_result['details']['solde_xp']
            if '[' in xp_line:
                suggestions['ameliorations'].append({
                    'type': 'Calculs XP',
                    'description': "Compl√©ter les calculs d'exp√©rience avec les vrais chiffres",
                    'priority': 'Moyenne'
                })
        
        # 5. SUGGESTIONS DE FORMATAGE
        if len(original_content) > 1800:
            suggestions['ameliorations'].append({
                'type': 'Longueur du message',
                'description': "Consid√©rer diviser en plusieurs messages pour Discord",
                'priority': 'Basse'
            })
        
        # 6. G√âN√âRER UN TEMPLATE PARTIELLEMENT CORRIG√â
        if suggestions['automatic_fixes']:
            suggestions['corrected_template'] = self._apply_automatic_fixes(corrected_content, verification_result)
        
        return suggestions

    def _apply_automatic_fixes(self, content: str, verification_result: dict) -> str:
        """Applique les corrections automatiques possibles"""
        
        corrected = content
        
        # Correction des s√©parateurs manquants
        if 'separator_pj_start' in verification_result['sections_missing']:
            if '** /' not in corrected and 'Classe' in corrected:
                corrected = re.sub(
                    r'(Classe\s*:\s*.+?)(\n|$)',
                    r'\1\n\n** / =======================  PJ  ========================= \\ **\n',
                    corrected,
                    count=1,
                    flags=re.MULTILINE
                )
        
        if 'separator_pj_end' in verification_result['sections_missing']:
            if '** \\' not in corrected and 'Solde' in corrected:
                corrected = re.sub(
                    r'(\*\*¬§\s*Solde\s*:\*\*)',
                    r'** \\ =======================  PJ  ========================= / **\n\n\1',
                    corrected,
                    count=1
                )
        
        # Ajout des sections manquantes de base
        missing = verification_result['sections_missing']
        
        # Ins√©rer les sections manquantes dans l'ordre logique
        if 'quete' in missing and '**Qu√™te' not in corrected:
            if '** /' in corrected:
                corrected = re.sub(
                    r'(\*\* / =+ PJ =+ \\ \*\*\n)',
                    r'\1**Qu√™te :** [TITRE_QUETE] + [NOM_MJ] ‚Å†- [LIEN_MESSAGE_RECOMPENSES]\n',
                    corrected,
                    count=1
                )
        
        if 'solde_xp' in missing and '**Solde XP' not in corrected:
            if '**Qu√™te' in corrected:
                corrected = re.sub(
                    r'(\*\*Qu√™te\s*:\*\*.*?\n)',
                    r'\1**Solde XP :** [XP_ACTUELS]/[XP_REQUIS] + [XP_OBTENUS] = [NOUVEAUX_XP]/[XP_REQUIS] -> üÜô passage au niveau [NOUVEAU_NIVEAU]\n\n',
                    corrected,
                    count=1,
                    flags=re.DOTALL
                )
        
        return corrected

    def _create_verification_embed(self, message: discord.Message, result: dict, suggestions: dict = None) -> discord.Embed:
        """Cr√©e l'embed avec les r√©sultats de v√©rification et suggestions"""
        
        # Calculer le pourcentage de conformit√©
        score_percentage = (result['score'] / result['total_checks']) * 100 if result['total_checks'] > 0 else 0
        
        # D√©terminer la couleur selon le score
        if score_percentage >= 90:
            color = 0x2ecc71  # Vert
            status_emoji = "‚úÖ"
            status_text = "Excellent"
        elif score_percentage >= 70:
            color = 0xf39c12  # Orange
            status_emoji = "‚ö†Ô∏è"
            status_text = "Bon"
        elif score_percentage >= 50:
            color = 0xff9900  # Orange fonc√©
            status_emoji = "üî∏"
            status_text = "Passable"
        else:
            color = 0xe74c3c  # Rouge
            status_emoji = "‚ùå"
            status_text = "Insuffisant"
        
        embed = discord.Embed(
            title=f"{status_emoji} V√©rification + Suggestions de MAJ",
            description=f"**Statut :** {status_text} ({score_percentage:.0f}%)",
            color=color
        )
        
        # Informations du message
        embed.add_field(
            name="üìù Message analys√©",
            value=f"**Auteur :** {message.author.mention}\n**Canal :** {message.channel.mention}\n**Date :** {discord.utils.format_dt(message.created_at, 'R')}",
            inline=False
        )
        
        # Score de conformit√©
        embed.add_field(
            name="üìä Score de conformit√©",
            value=f"**{result['score']}/{result['total_checks']}** √©l√©ments obligatoires trouv√©s\n**{score_percentage:.1f}%** de conformit√©",
            inline=True
        )
        
        # Caract√©ristiques d√©tect√©es
        if result['details'].get('nom_pj') or result['details'].get('classe'):
            char_info = []
            if result['details'].get('nom_pj'):
                char_info.append(f"**PJ :** {result['details']['nom_pj']}")
            if result['details'].get('classe'):
                char_info.append(f"**Classe :** {result['details']['classe']}")
            
            embed.add_field(
                name="üé≠ Personnage d√©tect√©",
                value="\n".join(char_info),
                inline=True
            )
        
        # NOUVEAU : Corrections automatiques disponibles
        if suggestions and suggestions.get('automatic_fixes'):
            fixes_text = "\n".join([f"‚úÖ {fix}" for fix in suggestions['automatic_fixes'][:3]])
            embed.add_field(
                name="üîß Corrections automatiques appliqu√©es",
                value=fixes_text,
                inline=False
            )
        
        # NOUVEAU : Suggestions de corrections
        if suggestions and suggestions.get('corrections'):
            corrections_text = []
            for correction in suggestions['corrections'][:3]:
                corrections_text.append(f"**{correction['section']}** - {correction['position']}")
            
            embed.add_field(
                name="üõ†Ô∏è Sections √† ajouter",
                value="\n".join(corrections_text),
                inline=False
            )
        
        # NOUVEAU : Am√©liorations sugg√©r√©es
        if suggestions and suggestions.get('ameliorations'):
            ameliorations_text = []
            for amelioration in suggestions['ameliorations'][:3]:
                priority_emoji = {"Haute": "üî¥", "Moyenne": "üü°", "Basse": "üü¢"}.get(amelioration['priority'], "‚ö™")
                ameliorations_text.append(f"{priority_emoji} **{amelioration['type']}** : {amelioration['description']}")
            
            embed.add_field(
                name="üí° Am√©liorations sugg√©r√©es",
                value="\n".join(ameliorations_text),
                inline=False
            )
        
        # Sections manquantes (si il y en a et pas de suggestions)
        if result['sections_missing'] and not suggestions:
            missing_labels = {
                'nom_pj': 'Nom du PJ',
                'classe': 'Classe',
                'separator_pj_start': 'S√©parateur d√©but PJ',
                'quete': 'Section Qu√™te',
                'solde_xp': 'Solde XP',
                'gain_niveau': 'Gain de niveau',
                'pv_calcul': 'Calcul PV',
                'capacites': 'Capacit√©s et sorts',
                'separator_pj_end': 'S√©parateur fin PJ',
                'solde_final': 'Solde final',
                'fiche_maj': 'Mention "Fiche R20 √† jour"'
            }
            
            missing_list = [missing_labels.get(key, key) for key in result['sections_missing'][:5]]
            if len(result['sections_missing']) > 5:
                missing_list.append(f"... et {len(result['sections_missing']) - 5} autres")
            
            embed.add_field(
                name="‚ùå Sections manquantes",
                value="\n".join([f"‚Ä¢ {item}" for item in missing_list]),
                inline=False
            )
        
        # Avertissements
        if result['warnings']:
            embed.add_field(
                name="‚ö†Ô∏è Avertissements",
                value="\n".join([f"‚Ä¢ {w}" for w in result['warnings'][:3]]),
                inline=False
            )
        
        # Conseils selon le score
        if score_percentage < 70:
            embed.add_field(
                name="üéØ Actions recommand√©es",
                value="‚Ä¢ Consultez le template corrig√© ci-dessous\n‚Ä¢ Utilisez `/maj-fiche` pour un nouveau template\n‚Ä¢ Compl√©tez les placeholders [EN_MAJUSCULES]\n‚Ä¢ V√©rifiez les calculs XP et PV",
                inline=False
            )
        
        # Lien vers le message
        embed.add_field(
            name="üîó Actions",
            value=f"[üìñ Voir le message original]({message.jump_url})",
            inline=True
        )
        
        embed.set_footer(text=f"V√©rification avec suggestions ‚Ä¢ Message ID: {message.id}")
        embed.timestamp = discord.utils.utcnow()
        
        return embed

    async def _send_corrected_template(self, interaction: discord.Interaction, corrected_template: str):
        """Envoie le template corrig√© en follow-up"""
        
        # Diviser le template si trop long
        max_length = 1900
        
        if len(corrected_template) <= max_length:
            # Template complet
            embed = discord.Embed(
                title="üîß Template Corrig√©",
                description=f"Voici votre template avec les corrections automatiques appliqu√©es :",
                color=0x2ecc71
            )
            
            embed.add_field(
                name="üìã Template am√©lior√©",
                value=f"```\n{corrected_template}\n```",
                inline=False
            )
            
            embed.add_field(
                name="‚úÖ Corrections appliqu√©es",
                value="‚Ä¢ S√©parateurs PJ ajout√©s\n‚Ä¢ Sections manquantes ins√©r√©es\n‚Ä¢ Structure am√©lior√©e",
                inline=False
            )
            
            embed.add_field(
                name="üìù Prochaines √©tapes",
                value="1. Copiez le template corrig√©\n2. Remplacez les placeholders [EN_MAJUSCULES]\n3. Compl√©tez les calculs XP et PV\n4. V√©rifiez les informations personnage",
                inline=False
            )
            
            await interaction.followup.send(embed=embed, ephemeral=True)
        
        else:
            # Template trop long - diviser
            embed = discord.Embed(
                title="üîß Template Corrig√© (Partie 1)",
                description="Template trop long - divis√© en plusieurs parties",
                color=0x2ecc71
            )
            
            parts = self._split_template_for_discord(corrected_template)
            
            for i, part in enumerate(parts, 1):
                part_embed = discord.Embed(
                    title=f"üîß Template Corrig√© - Partie {i}/{len(parts)}",
                    description=f"```\n{part}\n```",
                    color=0x2ecc71
                )
                
                if i == len(parts):  # Derni√®re partie
                    part_embed.add_field(
                        name="‚úÖ Corrections appliqu√©es",
                        value="‚Ä¢ S√©parateurs PJ ajout√©s\n‚Ä¢ Sections manquantes ins√©r√©es\n‚Ä¢ Structure am√©lior√©e",
                        inline=False
                    )
                
                await interaction.followup.send(embed=part_embed, ephemeral=True)

    def _split_template_for_discord(self, template: str) -> list:
        """Divise le template pour respecter les limites Discord"""
        max_length = 1900
        parts = []
        
        if len(template) <= max_length:
            return [template]
        
        lines = template.split('\n')
        current_part = ""
        
        for line in lines:
            if len(current_part + line + '\n') > max_length:
                if current_part:
                    parts.append(current_part.rstrip())
                current_part = line + '\n'
            else:
                current_part += line + '\n'
        
        if current_part:
            parts.append(current_part.rstrip())
        
        return parts