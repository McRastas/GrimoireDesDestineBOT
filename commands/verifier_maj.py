# commands/verifier_maj.py
"""
Commande de v√©rification de template de mise √† jour de fiche D&D.
Version am√©lior√©e utilisant les modules du r√©pertoire maj_fiche.
"""

import discord
from discord import app_commands
import re
import logging
from typing import Optional, Dict, Any
from .base import BaseCommand

# Import des modules maj_fiche pour la logique de validation
from .maj_fiche.validation_system import TemplateValidator
from .maj_fiche.template_generator import TemplateGenerator
from .maj_fiche.main_command import MajFicheBaseCommand

logger = logging.getLogger(__name__)


class VerifierMajCommand(BaseCommand):
    """
    Commande pour v√©rifier et corriger les templates de mise √† jour de fiche D&D.
    Utilise les modules maj_fiche pour une validation coh√©rente.
    """

    def __init__(self, bot):
        super().__init__(bot)
        self.validator = TemplateValidator()
        self.generator = TemplateGenerator()
        self.base_command = MajFicheBaseCommand(bot)

    @property
    def name(self) -> str:
        return "verifier-maj"

    @property
    def description(self) -> str:
        return "V√©rifie et propose des corrections pour un template de mise √† jour de fiche D&D"

    def register(self, tree: app_commands.CommandTree):
        """Enregistrement avec param√®tres optimis√©s"""

        @tree.command(name=self.name, description=self.description)
        @app_commands.describe(
            lien_message="Lien vers le message √† v√©rifier (clic droit > Copier le lien du message)",
            mode_correction="Type de correction √† appliquer",
            proposer_ameliorations="Proposer des am√©liorations suppl√©mentaires"
        )
        @app_commands.choices(mode_correction=[
            app_commands.Choice(name="üîß Corrections automatiques + suggestions", value="auto"),
            app_commands.Choice(name="üìã V√©rification uniquement", value="check"),
            app_commands.Choice(name="‚ú® Corrections + optimisations avanc√©es", value="advanced")
        ])
        @app_commands.choices(proposer_ameliorations=[
            app_commands.Choice(name="‚úÖ Oui - Sugg√©rer des am√©liorations", value="oui"),
            app_commands.Choice(name="‚ùå Non - Validation simple", value="non")
        ])
        async def verifier_maj_command(
            interaction: discord.Interaction,
            lien_message: str,
            mode_correction: str = "auto",
            proposer_ameliorations: str = "oui"
        ):
            await self.callback(
                interaction, 
                lien_message, 
                mode_correction, 
                proposer_ameliorations == "oui"
            )

    async def callback(
        self, 
        interaction: discord.Interaction, 
        lien_message: str,
        mode_correction: str = "auto",
        proposer_ameliorations: bool = True
    ):
        """Callback principal avec gestion d'erreur robuste"""
        try:
            # Diff√©rer la r√©ponse pour √©viter les timeouts
            await interaction.response.defer(ephemeral=True)
            
            logger.info(f"V√©rification template demand√©e par {interaction.user} - Mode: {mode_correction}")
            
            # Parser et valider le lien Discord
            message_info = self._parse_discord_link(lien_message)
            if not message_info:
                await interaction.followup.send(
                    embed=self._create_error_embed(
                        "Lien invalide",
                        "Utilisez un lien Discord valide :\n"
                        "‚Ä¢ **Clic droit** sur le message ‚Üí **Copier le lien du message**\n"
                        "‚Ä¢ Format attendu : `https://discord.com/channels/123.../456.../789...`\n\n"
                        "üí° **Astuce :** Activez le Mode D√©veloppeur dans Discord si n√©cessaire."
                    ),
                    ephemeral=True
                )
                return

            # R√©cup√©rer le message Discord
            message = await self._fetch_discord_message(interaction, message_info)
            if not message:
                return  # L'erreur a d√©j√† √©t√© envoy√©e

            # V√©rifier le contenu du message
            if not message.content.strip():
                await interaction.followup.send(
                    embed=self._create_error_embed(
                        "Message vide",
                        "Le message ne contient pas de texte √† analyser.\n"
                        "V√©rifiez que vous avez s√©lectionn√© le bon message avec le template de MAJ."
                    ),
                    ephemeral=True
                )
                return

            # Effectuer la validation avec le syst√®me maj_fiche
            verification_result = self.validator.verify_template(message.content)
            
            # G√©n√©rer les corrections selon le mode choisi
            corrections = None
            if mode_correction in ["auto", "advanced"]:
                corrections = self.validator.generate_corrections(message.content, verification_result)
                
                # Mode avanc√© : ajouter des optimisations suppl√©mentaires
                if mode_correction == "advanced":
                    corrections = self._add_advanced_optimizations(corrections, message.content)

            # Cr√©er l'embed de r√©sultats
            result_embed = self._create_verification_embed(
                message, verification_result, corrections, mode_correction
            )
            
            # Envoyer l'embed de r√©sultats
            await interaction.followup.send(embed=result_embed, ephemeral=True)
            
            # Envoyer le template corrig√© si n√©cessaire
            if mode_correction != "check":
                await self._send_corrected_template(
                    interaction, message.content, verification_result, corrections, proposer_ameliorations
                )
            
            logger.info(f"V√©rification termin√©e avec succ√®s pour {interaction.user}")
            
        except Exception as e:
            logger.error(f"Erreur dans verifier-maj: {e}", exc_info=True)
            
            error_embed = self._create_error_embed(
                "Erreur inattendue",
                f"Une erreur s'est produite lors de la v√©rification.\n\n"
                f"**Erreur :** {str(e)}\n\n"
                f"üí° **Solutions :**\n"
                f"‚Ä¢ V√©rifiez que le lien est correct et complet\n"
                f"‚Ä¢ R√©essayez dans quelques instants\n"
                f"‚Ä¢ Contactez un administrateur si le probl√®me persiste"
            )
            
            try:
                await interaction.followup.send(embed=error_embed, ephemeral=True)
            except:
                logger.error(f"Impossible d'envoyer le message d'erreur pour {interaction.user}")

    def _parse_discord_link(self, link: str) -> Optional[tuple]:
        """
        Parse un lien Discord pour extraire guild_id, channel_id, message_id.
        Version am√©lior√©e avec support de plusieurs formats.
        """
        # Nettoyer le lien
        link = link.strip().strip('<>')
        
        # Ajouter https:// si manquant
        if not link.startswith(('http://', 'https://')):
            if link.startswith('discord'):
                link = 'https://' + link
            else:
                return None
        
        # Patterns pour diff√©rents formats Discord
        patterns = [
            r'https?://(?:www\.)?discord(?:app)?\.com/channels/(\d+)/(\d+)/(\d+)',
            r'https?://(?:www\.)?discord\.gg/channels/(\d+)/(\d+)/(\d+)',
            r'https?://ptb\.discord(?:app)?\.com/channels/(\d+)/(\d+)/(\d+)',
            r'https?://canary\.discord(?:app)?\.com/channels/(\d+)/(\d+)/(\d+)'
        ]
        
        for pattern in patterns:
            match = re.match(pattern, link)
            if match:
                try:
                    return (int(match.group(1)), int(match.group(2)), int(match.group(3)))
                except ValueError:
                    continue
        
        return None

    async def _fetch_discord_message(
        self, 
        interaction: discord.Interaction, 
        message_info: tuple
    ) -> Optional[discord.Message]:
        """R√©cup√®re le message Discord avec gestion d'erreur compl√®te"""
        
        guild_id, channel_id, message_id = message_info
        
        # V√©rifier le serveur
        if guild_id != interaction.guild.id:
            await interaction.followup.send(
                embed=self._create_error_embed(
                    "Serveur diff√©rent",
                    f"Le message se trouve sur un autre serveur.\n\n"
                    f"‚Ä¢ **Message :** Serveur ID `{guild_id}`\n"
                    f"‚Ä¢ **Commande :** Serveur ID `{interaction.guild.id}`\n\n"
                    f"Utilisez cette commande sur le m√™me serveur que le message."
                ),
                ephemeral=True
            )
            return None
        
        # R√©cup√©rer le canal
        try:
            channel = interaction.guild.get_channel(int(channel_id))
            if not channel:
                await interaction.followup.send(
                    embed=self._create_error_embed(
                        "Canal introuvable",
                        f"Le canal avec l'ID `{channel_id}` n'existe pas ou n'est pas accessible.\n\n"
                        f"**V√©rifiez que :**\n"
                        f"‚Ä¢ Le canal existe toujours\n"
                        f"‚Ä¢ Le bot a acc√®s √† ce canal\n"
                        f"‚Ä¢ Le lien est correct"
                    ),
                    ephemeral=True
                )
                return None
        except Exception as e:
            await interaction.followup.send(
                embed=self._create_error_embed(
                    "Erreur d'acc√®s au canal",
                    f"Impossible d'acc√©der au canal : {str(e)}"
                ),
                ephemeral=True
            )
            return None
        
        # R√©cup√©rer le message
        try:
            message = await channel.fetch_message(int(message_id))
            return message
        except discord.NotFound:
            await interaction.followup.send(
                embed=self._create_error_embed(
                    "Message introuvable",
                    f"Le message avec l'ID `{message_id}` n'existe pas dans {channel.mention}.\n\n"
                    f"**V√©rifiez que :**\n"
                    f"‚Ä¢ Le message n'a pas √©t√© supprim√©\n"
                    f"‚Ä¢ Le lien est correct et complet\n"
                    f"‚Ä¢ Vous avez copi√© le bon lien"
                ),
                ephemeral=True
            )
            return None
        except discord.Forbidden:
            await interaction.followup.send(
                embed=self._create_error_embed(
                    "Acc√®s refus√©",
                    f"Le bot n'a pas les permissions pour lire les messages dans {channel.mention}.\n"
                    f"Contactez un administrateur pour accorder les permissions n√©cessaires."
                ),
                ephemeral=True
            )
            return None
        except Exception as e:
            await interaction.followup.send(
                embed=self._create_error_embed(
                    "Erreur de r√©cup√©ration",
                    f"Erreur lors de la r√©cup√©ration du message : {str(e)}"
                ),
                ephemeral=True
            )
            return None

    def _create_verification_embed(
        self, 
        message: discord.Message, 
        verification_result: Dict[str, Any],
        corrections: Optional[Dict[str, Any]] = None,
        mode: str = "auto"
    ) -> discord.Embed:
        """Cr√©e l'embed de r√©sultats de v√©rification avec les infos maj_fiche"""
        
        completion = verification_result.get('completion_percentage', 0)
        
        # D√©terminer couleur et statut
        if completion >= 90:
            color, emoji, status = 0x2ecc71, "‚úÖ", "Excellent"
        elif completion >= 70:
            color, emoji, status = 0xf39c12, "üü°", "Bon"
        elif completion >= 50:
            color, emoji, status = 0xff9900, "üü†", "Passable"
        else:
            color, emoji, status = 0xe74c3c, "‚ùå", "Insuffisant"
        
        embed = discord.Embed(
            title=f"{emoji} V√©rification Template D&D",
            description=f"**Statut :** {status} ({completion:.0f}% complet)",
            color=color
        )
        
        # Informations du message
        embed.add_field(
            name="üìù Message analys√©",
            value=(
                f"**Auteur :** {message.author.mention}\n"
                f"**Canal :** {message.channel.mention}\n"
                f"**Date :** {discord.utils.format_dt(message.created_at, 'R')}"
            ),
            inline=False
        )
        
        # Score d√©taill√© avec syst√®me maj_fiche
        score_text = (
            f"**{verification_result['score']}/{verification_result['total_checks']}** sections obligatoires\n"
            f"**{completion:.1f}%** de conformit√©\n"
            f"**{len(verification_result.get('placeholders', []))}** placeholders √† compl√©ter"
        )
        embed.add_field(
            name="üìä Analyse d√©taill√©e",
            value=score_text,
            inline=True
        )
        
        # Informations personnage d√©tect√©es
        details = verification_result.get('details', {})
        if details.get('nom_pj') or details.get('classe'):
            char_info = []
            if details.get('nom_pj'):
                char_info.append(f"**PJ :** {details['nom_pj']}")
            if details.get('classe'):
                char_info.append(f"**Classe :** {details['classe']}")
            
            embed.add_field(
                name="üé≠ Personnage",
                value=self._safe_field_value("\n".join(char_info)),
                inline=True
            )
        
        # Sections manquantes (limit√©es pour l'affichage)
        if verification_result.get('sections_missing'):
            missing_labels = []
            section_labels = {
                'nom_pj': 'Nom PJ', 'classe': 'Classe', 'quete': 'Qu√™te',
                'solde_xp': 'Solde XP', 'gain_niveau': 'Gain niveau',
                'capacites': 'Capacit√©s', 'solde_final': 'Solde final'
            }
            
            for section in verification_result['sections_missing'][:5]:
                label = section_labels.get(section, section)
                missing_labels.append(f"‚Ä¢ {label}")
            
            if len(verification_result['sections_missing']) > 5:
                missing_labels.append(f"‚Ä¢ ... et {len(verification_result['sections_missing']) - 5} autres")
            
            embed.add_field(
                name="‚ùå Sections manquantes",
                value=self._safe_field_value("\n".join(missing_labels)),
                inline=False
            )
        
        # Corrections automatiques appliqu√©es
        if corrections and corrections.get('automatic_fixes'):
            fixes_text = "\n".join([f"‚úÖ {fix}" for fix in corrections['automatic_fixes'][:4]])
            embed.add_field(
                name="üîß Corrections automatiques",
                value=self._safe_field_value(fixes_text),
                inline=False
            )
        
        # Alertes importantes
        warnings = verification_result.get('warnings', [])
        if warnings:
            warnings_text = "\n".join([f"‚ö†Ô∏è {w}" for w in warnings[:3]])
            embed.add_field(
                name="‚ö†Ô∏è Alertes",
                value=self._safe_field_value(warnings_text),
                inline=False
            )
        
        # Footer avec informations sur le mode
        mode_descriptions = {
            "check": "Mode v√©rification uniquement",
            "auto": "Mode corrections automatiques",
            "advanced": "Mode optimisations avanc√©es"
        }
        
        embed.set_footer(
            text=f"{mode_descriptions.get(mode, 'Mode inconnu')} ‚Ä¢ Syst√®me maj_fiche v2.0"
        )
        embed.timestamp = discord.utils.utcnow()
        
        return embed

    def _add_advanced_optimizations(
        self, 
        corrections: Dict[str, Any], 
        content: str
    ) -> Dict[str, Any]:
        """Ajoute des optimisations avanc√©es au mode advanced"""
        
        if not corrections.get('improvements'):
            corrections['improvements'] = []
        
        # Optimisations avanc√©es sp√©cifiques
        
        # 1. Optimisation des calculs XP avec table D&D
        if re.search(r'\[XP_', content):
            corrections['improvements'].append({
                'type': 'Calculs XP automatiques',
                'description': 'Utiliser les calculs automatiques XP bas√©s sur les niveaux D&D 5e',
                'priority': 'Haute',
                'template': '**Solde XP :** [XP_ACTUELS] + [XP_OBTENUS] = [NOUVEAUX_XP] -> üÜô passage au niveau [NOUVEAU_NIVEAU]'
            })
        
        # 2. Suggestions de sorts par classe
        if re.search(r'\[SORT_', content):
            classe_match = re.search(r'Classe\s*:\s*([A-Za-z√Ä-√ø]+)', content)
            if classe_match:
                classe = classe_match.group(1)
                suggestions = self.generator.add_class_specific_suggestions(classe, 3)  # Niveau exemple
                if suggestions.get('spells'):
                    corrections['improvements'].append({
                        'type': 'Suggestions de sorts',
                        'description': f'Sorts recommand√©s pour {classe} : {", ".join(suggestions["spells"][:3])}',
                        'priority': 'Moyenne'
                    })
        
        # 3. Optimisation de la structure
        if len(content) > 1800:
            corrections['improvements'].append({
                'type': 'Optimisation longueur',
                'description': 'R√©organiser le template pour optimiser la longueur Discord',
                'priority': 'Moyenne'
            })
        
        # 4. Validation des calculs PV
        if re.search(r'PV\s*:', content):
            corrections['improvements'].append({
                'type': 'Validation PV',
                'description': 'V√©rifier la coh√©rence des calculs de Points de Vie avec les modificateurs',
                'priority': 'Haute'
            })
        
        return corrections

    async def _send_corrected_template(
        self,
        interaction: discord.Interaction,
        original_content: str,
        verification_result: Dict[str, Any],
        corrections: Optional[Dict[str, Any]],
        include_improvements: bool
    ):
        """Envoie le template corrig√© en utilisant la logique maj_fiche"""
        
        # D√©terminer le template √† envoyer
        if corrections and corrections.get('corrected_template'):
            final_template = corrections['corrected_template']
            template_type = "corrig√©"
        else:
            # Utiliser le nettoyage basique si pas de corrections
            final_template = self._clean_template_basic(original_content)
            template_type = "nettoy√©"
        
        # Calculer les statistiques avec le syst√®me maj_fiche
        template_stats = self.generator.get_template_stats(final_template)
        
        # Cr√©er l'embed principal
        embed = discord.Embed(
            title=f"üìã Template D&D {template_type.title()}",
            description=f"Votre template a √©t√© {template_type} et optimis√© avec le syst√®me maj_fiche.",
            color=0x2ecc71 if template_type == "corrig√©" else 0x3498db
        )
        
        # Statistiques du template
        embed.add_field(
            name="üìä Statistiques",
            value=(
                f"**Caract√®res :** {template_stats['length']}/2000\n"
                f"**Placeholders :** {template_stats['placeholders']}\n"
                f"**Sections :** {template_stats['sections']}"
            ),
            inline=True
        )
        
        # R√©sum√© des corrections
        if corrections:
            fixes_count = len(corrections.get('automatic_fixes', []))
            manual_count = len(corrections.get('manual_corrections', []))
            
            embed.add_field(
                name="üîß Corrections appliqu√©es",
                value=(
                    f"**Automatiques :** {fixes_count}\n"
                    f"**Manuelles sugg√©r√©es :** {manual_count}\n"
                    f"**Qualit√© :** {self.validator.get_validation_summary(verification_result)}"
                ),
                inline=True
            )
        
        # Instructions selon l'√©tat
        placeholder_count = template_stats['placeholders']
        if placeholder_count > 0:
            embed.add_field(
                name="üìù Prochaines √©tapes",
                value=(
                    f"1. **Copiez** le template ci-dessous\n"
                    f"2. **Compl√©tez** les {placeholder_count} placeholders [EN_MAJUSCULES]\n"
                    f"3. **V√©rifiez** les calculs XP et PV\n"
                    f"4. **Utilisez** dans le canal appropri√©"
                ),
                inline=False
            )
        else:
            embed.add_field(
                name="üéØ Template pr√™t !",
                value="‚úÖ Aucun placeholder √† compl√©ter\n‚úÖ Pr√™t √† utiliser directement\n‚úÖ Valid√© par le syst√®me maj_fiche",
                inline=False
            )
        
        # Envoyer l'embed d'introduction
        await interaction.followup.send(embed=embed, ephemeral=True)
        
        # Envoyer le template selon sa longueur
        if template_stats['needs_splitting']:
            await self._send_template_multipart(interaction, final_template, template_stats)
        else:
            await self._send_template_single(interaction, final_template, template_stats)
        
        # Envoyer les am√©liorations sugg√©r√©es si demand√©es
        if include_improvements and corrections and corrections.get('improvements'):
            await self._send_improvements_suggestions(interaction, corrections['improvements'])

    async def _send_template_single(
        self, 
        interaction: discord.Interaction, 
        template: str, 
        stats: Dict[str, Any]
    ):
        """Envoie un template en une seule partie"""
        
        embed = discord.Embed(
            title="üìÑ Votre Template Final",
            description=f"Template complet ({stats['length']} caract√®res)",
            color=0x3498db
        )
        
        # Diviser le template en chunks pour l'embed
        max_field_length = 1020
        if len(template) <= max_field_length:
            embed.add_field(
                name="Template complet",
                value=f"```\n{template}\n```",
                inline=False
            )
        else:
            # Template trop long m√™me pour un seul embed
            template_chunks = [template[i:i+max_field_length-10] for i in range(0, len(template), max_field_length-10)]
            
            for i, chunk in enumerate(template_chunks[:3]):  # Limiter √† 3 chunks max
                embed.add_field(
                    name=f"Template (partie {i+1})" if len(template_chunks) > 1 else "Template",
                    value=f"```\n{chunk}\n```",
                    inline=False
                )
        
        await interaction.followup.send(embed=embed, ephemeral=True)

    async def _send_template_multipart(
        self, 
        interaction: discord.Interaction, 
        template: str, 
        stats: Dict[str, Any]
    ):
        """Envoie un template divis√© en plusieurs parties"""
        
        parts = self.generator.split_template_if_needed(template)
        
        for i, part in enumerate(parts, 1):
            embed = discord.Embed(
                title=f"üìÑ Template - Partie {i}/{len(parts)}",
                description=f"```\n{part}\n```",
                color=0x3498db
            )
            
            embed.add_field(
                name="üìè Informations",
                value=f"**Partie :** {i}/{len(parts)}\n**Caract√®res :** {len(part)}",
                inline=True
            )
            
            if i == 1:
                embed.add_field(
                    name="üí° Instructions",
                    value="Copiez chaque partie dans l'ordre et assemblez-les",
                    inline=True
                )
            elif i == len(parts):
                embed.add_field(
                    name="‚úÖ Termin√©",
                    value=f"Template complet reconstitu√© ! Total: {stats['length']} caract√®res",
                    inline=True
                )
            
            await interaction.followup.send(embed=embed, ephemeral=True)

    async def _send_improvements_suggestions(
        self, 
        interaction: discord.Interaction, 
        improvements: list
    ):
        """Envoie les suggestions d'am√©lioration"""
        
        if not improvements:
            return
        
        embed = discord.Embed(
            title="üí° Suggestions d'Am√©lioration",
            description="Am√©liorations suppl√©mentaires recommand√©es pour votre template :",
            color=0xf39c12
        )
        
        priority_colors = {"Haute": "üî¥", "Moyenne": "üü°", "Basse": "üü¢"}
        
        for i, improvement in enumerate(improvements[:5], 1):  # Limiter √† 5 suggestions
            priority = improvement.get('priority', 'Moyenne')
            priority_emoji = priority_colors.get(priority, "‚ö™")
            
            embed.add_field(
                name=f"{priority_emoji} {improvement.get('type', 'Am√©lioration')}",
                value=f"{improvement.get('description', 'Aucune description')}\n**Priorit√© :** {priority}",
                inline=False
            )
        
        if len(improvements) > 5:
            embed.add_field(
                name="üìù Note",
                value=f"+ {len(improvements) - 5} autres suggestions disponibles",
                inline=False
            )
        
        await interaction.followup.send(embed=embed, ephemeral=True)

    def _clean_template_basic(self, content: str) -> str:
        """Nettoyage basique du template sans les modules maj_fiche"""
        
        cleaned = content.strip()
        
        # Normaliser les espaces multiples
        cleaned = re.sub(r'\n{3,}', '\n\n', cleaned)
        
        # Normaliser les s√©parateurs PJ
        cleaned = re.sub(
            r'\*\*\s*/\s*=+\s*PJ\s*=+\s*\\\s*\*\*',
            '** / =======================  PJ  ========================= \\ **',
            cleaned
        )
        cleaned = re.sub(
            r'\*\*\s*\\\s*=+\s*PJ\s*=+\s*/\s*\*\*',
            '** \\ =======================  PJ  ========================= / **',
            cleaned
        )
        
        return cleaned

    def _create_error_embed(self, title: str, description: str) -> discord.Embed:
        """Cr√©e un embed d'erreur standardis√©"""
        
        embed = discord.Embed(
            title=f"‚ùå {title}",
            description=description,
            color=0xe74c3c
        )
        
        embed.set_footer(text="Commande verifier-maj ‚Ä¢ Syst√®me maj_fiche")
        embed.timestamp = discord.utils.utcnow()
        
        return embed

    def _safe_field_value(self, text: str, max_length: int = 1020) -> str:
        """S√©curise un texte pour les champs Discord"""
        if len(text) <= max_length:
            return text
        return text[:max_length-3] + "..."