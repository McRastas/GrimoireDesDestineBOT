# commands/verifier_maj/response_builder.py
"""Constructeur de r√©ponses Discord pour verifier_maj."""

import discord
import logging
from typing import Dict, Any, List

logger = logging.getLogger(__name__)


class ResponseBuilder:
    """Construit et envoie les r√©ponses Discord avec gestion des limites."""
    
    def __init__(self):
        self.colors = {
            'success': 0x00ff00,
            'warning': 0xffaa00,
            'error': 0xff0000,
            'info': 0x3498db
        }
        
        # Limites Discord
        self.FIELD_VALUE_LIMIT = 1024
        self.EMBED_DESCRIPTION_LIMIT = 4096
        self.MESSAGE_CONTENT_LIMIT = 2000
    
    def _safe_field_value(self, text: str, max_length: int = None) -> str:
        """Tronque un texte pour qu'il respecte les limites Discord."""
        if max_length is None:
            max_length = self.FIELD_VALUE_LIMIT - 50  # Marge de s√©curit√©
        
        if len(text) <= max_length:
            return text
        
        # Tronquer intelligemment
        truncated = text[:max_length-10]
        if '\n' in truncated:
            # Couper √† la derni√®re ligne compl√®te
            truncated = truncated.rsplit('\n', 1)[0]
        
        return truncated + "\n... (tronqu√©)"
    
    async def send_validation_result(self, interaction: discord.Interaction, 
                                   message: discord.Message, result: Dict[str, Any], 
                                   include_suggestions: bool = True):
        """Envoie le r√©sultat de validation complet."""
        
        try:
            # Cr√©er l'embed principal
            embed = self._create_validation_embed(message, result)
            
            # S'assurer qu'on n'a pas d√©j√† r√©pondu
            if not interaction.response.is_done():
                await interaction.response.defer(ephemeral=True)
            
            await interaction.followup.send(embed=embed, ephemeral=True)
            
            # Envoyer les corrections si disponibles
            if result.get('corrections_generated') and result.get('corrected_content'):
                await self._send_corrections(interaction, result['corrected_content'])
                
        except Exception as e:
            logger.error(f"Erreur lors de l'envoi du r√©sultat de validation: {e}")
            await self._safe_error_response(interaction, "Erreur lors de l'affichage des r√©sultats")
    
    def _create_validation_embed(self, message: discord.Message, result: Dict[str, Any]) -> discord.Embed:
        """Cr√©e l'embed de validation avec protection des limites."""
        completion = result.get('completion_percentage', 0)
        
        # Couleur bas√©e sur le score
        if completion >= 80:
            color = self.colors['success']
            status = "‚úÖ Template conforme"
        elif completion >= 50:
            color = self.colors['warning'] 
            status = "‚ö†Ô∏è Template √† am√©liorer"
        else:
            color = self.colors['error']
            status = "‚ùå Template incomplet"
        
        embed = discord.Embed(
            title="üîç V√©rification de template",
            description=status,
            color=color
        )
        
        # Statistiques de base
        score_text = (
            f"**{result['score']}/{result['total_checks']}** sections obligatoires\n"
            f"**{completion:.1f}%** de conformit√©"
        )
        
        placeholders_count = len(result.get('placeholders', []))
        if placeholders_count > 0:
            score_text += f"\n**{placeholders_count}** placeholders √† compl√©ter"
        
        embed.add_field(
            name="üìä Analyse d√©taill√©e",
            value=score_text,
            inline=True
        )
        
        # Informations du personnage d√©tect√©es (avec limite)
        details = result.get('details', {})
        if details.get('nom_pj') or details.get('classe'):
            char_info = []
            if details.get('nom_pj'):
                char_info.append(f"**PJ :** {details['nom_pj']}")
            if details.get('classe'):
                char_info.append(f"**Classe :** {details['classe']}")
            
            embed.add_field(
                name="üé≠ Personnage",
                value=self._safe_field_value("\n".join(char_info)),
                inline=True
            )
        
        # Informations du message
        embed.add_field(
            name="üìù Message analys√©",
            value=f"Par {message.author.mention}\nDans {message.channel.mention}",
            inline=True
        )
        
        # Sections manquantes (limit√©es pour l'affichage)
        if result.get('sections_missing'):
            missing_labels = []
            section_labels = {
                'nom_pj': 'Nom PJ', 'classe': 'Classe', 'quete': 'Qu√™te',
                'solde_xp': 'Solde XP', 'gain_niveau': 'Gain niveau',
                'capacites': 'Capacit√©s', 'solde_final': 'Solde final'
            }
            
            # Limiter √† 5 sections pour √©viter de d√©passer la limite
            sections_to_show = result['sections_missing'][:5]
            for section in sections_to_show:
                label = section_labels.get(section, section)
                missing_labels.append(f"‚Ä¢ {label}")
            
            if len(result['sections_missing']) > 5:
                missing_labels.append(f"‚Ä¢ ... et {len(result['sections_missing']) - 5} autres")
            
            missing_text = "\n".join(missing_labels)
            embed.add_field(
                name="‚ùå Sections manquantes",
                value=self._safe_field_value(missing_text),
                inline=False
            )
        
        # Corrections disponibles
        if result.get('corrections_generated'):
            embed.add_field(
                name="üîß Corrections",
                value="‚úÖ Template corrig√© disponible ci-dessous",
                inline=False
            )
        
        # Avertissements (avec limite)
        warnings = result.get('warnings', [])
        if warnings:
            warnings_text = "\n".join([f"‚ö†Ô∏è {w}" for w in warnings[:3]])
            if len(warnings) > 3:
                warnings_text += f"\n... et {len(warnings) - 3} autres avertissements"
            
            embed.add_field(
                name="‚ö†Ô∏è Avertissements",
                value=self._safe_field_value(warnings_text),
                inline=False
            )
        
        return embed
    
    async def _send_corrections(self, interaction: discord.Interaction, corrected_content: str):
        """Envoie le template corrig√© en g√©rant les limites Discord."""
        try:
            # V√©rifier si le contenu est trop long pour un embed
            if len(corrected_content) > 1800:  # Marge de s√©curit√© pour l'embed
                # Diviser en plusieurs messages
                parts = self._split_content(corrected_content)
                for i, part in enumerate(parts):
                    embed = discord.Embed(
                        title=f"üîß Template corrig√© (partie {i+1}/{len(parts)})",
                        description=f"```\n{part}\n```",
                        color=self.colors['info']
                    )
                    await interaction.followup.send(embed=embed, ephemeral=True)
            else:
                embed = discord.Embed(
                    title="üîß Template corrig√©",
                    description=f"```\n{corrected_content}\n```",
                    color=self.colors['info']
                )
                await interaction.followup.send(embed=embed, ephemeral=True)
                
        except Exception as e:
            logger.error(f"Erreur lors de l'envoi des corrections: {e}")
            await interaction.followup.send(
                "‚ùå Erreur lors de l'envoi du template corrig√©.", 
                ephemeral=True
            )
    
    def _split_content(self, content: str, max_length: int = 1800) -> List[str]:
        """Divise le contenu en parties g√©rables pour Discord."""
        if len(content) <= max_length:
            return [content]
        
        parts = []
        lines = content.split('\n')
        current_part = ""
        
        for line in lines:
            # V√©rifier si ajouter cette ligne d√©passerait la limite
            if len(current_part) + len(line) + 1 <= max_length:
                current_part += line + '\n'
            else:
                # Sauvegarder la partie actuelle
                if current_part:
                    parts.append(current_part.rstrip())
                
                # Commencer une nouvelle partie
                current_part = line + '\n'
                
                # Si une seule ligne est trop longue, la tronquer
                if len(current_part) > max_length:
                    parts.append(line[:max_length-10] + "... (tronqu√©)")
                    current_part = ""
        
        # Ajouter la derni√®re partie
        if current_part:
            parts.append(current_part.rstrip())
        
        return parts
    
    async def send_error(self, interaction: discord.Interaction, error_message: str, 
                        title: str = "‚ùå Erreur"):
        """Envoie un message d'erreur de mani√®re s√©curis√©e."""
        await self._safe_error_response(interaction, error_message, title)
    
    async def _safe_error_response(self, interaction: discord.Interaction, 
                                  error_message: str, title: str = "‚ùå Erreur"):
        """Envoie une r√©ponse d'erreur en g√©rant les √©tats d'interaction."""
        embed = discord.Embed(
            title=title,
            description=self._safe_field_value(error_message, self.EMBED_DESCRIPTION_LIMIT),
            color=self.colors['error']
        )
        
        try:
            if not interaction.response.is_done():
                await interaction.response.send_message(embed=embed, ephemeral=True)
            else:
                await interaction.followup.send(embed=embed, ephemeral=True)
        except discord.InteractionResponded:
            # L'interaction a d√©j√† √©t√© trait√©e
            try:
                await interaction.followup.send(embed=embed, ephemeral=True)
            except Exception as e:
                logger.error(f"Impossible d'envoyer le message d'erreur: {e}")
        except Exception as e:
            logger.error(f"Erreur lors de l'envoi de la r√©ponse d'erreur: {e}")
            # Fallback: essayer un message simple
            try:
                simple_message = f"{title}: {error_message[:500]}"
                if not interaction.response.is_done():
                    await interaction.response.send_message(simple_message, ephemeral=True)
                else:
                    await interaction.followup.send(simple_message, ephemeral=True)
            except:
                # Dernier recours: log l'erreur
                logger.error(f"Impossible d'envoyer une r√©ponse √† l'utilisateur")
    
    async def send_link_validation_error(self, interaction: discord.Interaction, link: str):
        """Envoie un message d'erreur sp√©cifique pour les liens invalides."""
        error_message = (
            f"Le lien fourni n'est pas valide ou accessible.\n\n"
            f"**Lien fourni :** `{link[:100]}{'...' if len(link) > 100 else ''}`\n\n"
            f"üí° **Solutions :**\n"
            f"‚Ä¢ V√©rifiez que le lien est correct et complet\n"
            f"‚Ä¢ Assurez-vous que le bot a acc√®s au canal\n"
            f"‚Ä¢ Utilisez 'Copier le lien du message' (clic droit)\n"
            f"‚Ä¢ R√©essayez dans quelques instants"
        )
        await self.send_error(interaction, error_message, "üîó Lien invalide")
    
    async def send_message_not_found_error(self, interaction: discord.Interaction):
        """Envoie un message d'erreur quand le message n'est pas trouv√©."""
        error_message = (
            f"Le message n'a pas pu √™tre r√©cup√©r√©.\n\n"
            f"üí° **Causes possibles :**\n"
            f"‚Ä¢ Message supprim√©\n"
            f"‚Ä¢ Canal priv√© ou inaccessible\n"
            f"‚Ä¢ Permissions insuffisantes\n"
            f"‚Ä¢ Serveur diff√©rent"
        )
        await self.send_error(interaction, error_message, "üìù Message introuvable")